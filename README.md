# AutoTestingProjectQA
This is a Java application that I created several automated unit tests for using JUnit in Eclipse.

## Summary
I created 8 Junit tests for each of the features. I created a test for the Allergy, Doctor, Employee, MedicalRecord, MedicationTest, PatientHistoryTest, PatientTest, and TreatmentTest classes. I also created 2 Junit tests for each of the services. I created a test for the DoctorService and the MedicalRescordService classes. I tested each unit of each feature individually, then tested each service individually, then I created a test called AllModelTests to test every feature as a whole by creating a test suite and including every class in the suite. I also did this for the services by creating a test called AllServiceTests. I finally created a test for every feature of the entire program called AllTests. My reasoning in doing my testing this way based on the best practices that I have learned in this course are because using a consistent naming convention keeps my workspace organized and decreases confusion, keeping my test small makes my workflow more efficient, including my tests in their own directory keeps them separated from my application’s class files, and using Test-Driven Development allows me test my code as it is being developed which increases the overall quality of the product being developed.

I organized my test for each of the features based on whether they were a part of the application’s model package or the services package. I grouped all of the model tests into a single suite called AllModelTests and I grouped all of the service tests into single test suite called AllServiceTests. I did this because it allows me to keep my work organized and test all of the features together to see if they are compatible with one another.

I addressed all of the software requirements; I tested the doctor information feature requirement by passing a name and a unique ID into the setName and setd units in the doctor information feature. I tested the medical records feature requirement by passing a patient name and Id into the medical records feature, I tested the getPatient and getHistory units by calling the getPatient and getHistory functions from the medicalRecord class. I tested the allergy find Feature requirement by passing a patient name and Id who had an allergy and then used the getallpateintswithallergies function to add the patients with peanut allergies to a list.

I ensured that my code was technically sound and efficient by following the best coding practices such as using a consistent naming convention by appending Test to the end of each class name for each test. I also kept my tests small and lightweight in that they were simple and only tested what needed to be tested for each feature. I put all of my tests into their own directory and created sub directories within that folder for model tests, services tests and feature tests. I also implemented Test-Driven development by creating my tests then adding the functionality after so that it would pass the test. 

![Allergy](https://i.imgur.com/tb277ue.jpg)
![AllergyTest](https://i.imgur.com/33RF4MH.jpg)

In this program I have only found two errors in total. The first error is in the name of the Allergy class, the class name is spelled “Allergey” which is incorrect. The second error that I found was in the MedicalRecordService class, the class name is spelled “MedicalRescordService” which is also incorrect.

## Reflection
The testing techniques that were employed in this project were unit testing, integration testing, and acceptance testing techniques. I used unit testing techniques such as the state transition technique when testing the function of each class individually by assigning input values to be passed through each function such as the name and ID for a patient. After testing each unit, I used integration testing techniques to test the compatibility of each unit with each other, I accomplished this by testing each model individually to see if the program would throw any errors related to the units in each model. The final technique that I employed was an acceptance testing technique, in doing this I created a test for every model and service in the program and tested the overall functionality of the program.

Some other software testing techniques that I learned about in this course are black-box techniques, white-box techniques, ad experience-based techniques. Some black-box techniques that we have discussed throughout this course are equivalence partitioning, boundary value analysis, decision table testing, and use case testing. The white-box techniques that were learned throughout this course were statement testing and decision testing. The experience-based techniques that were learned were error guessing and exploratory testing.

The practical use of the black-box techniques mentioned previously is to test the functionality of the application under test with no knowledge the internal code structure, implementation details or knowledge of how the data travels through the software, the purpose of this is to validate that the software meets the functional requirements. The practical use of white-box testing techniques is to test the internal structure, design and coding with full knowledge of the code and the internal working of the software to verify the flow of data through the application in order to improve the design of the application. The practical use of experience-based testing is to allow testers to apply their previous testing experiences to verify and validate a software product when there is very limited knowledge of the product or inadequate specifications.

Properly managing software testing is important because it improves the efficiency of the software development life cycle. By implementing the best practices when managing software testing, we reduce the amount of time and cost spent on producing a product while improving the overall quality of the product itself. In certain scenarios managing software testing can have life threating consequences. For example, if developers are creating a software for a hospital if the software testing aspect of the development process isn’t managed properly it could result in a defective product being deliver, which could indivertibly cost people their lives. In scenarios like this testing is extremely important and may take precedence over the creation the product itself. The risks of not verifying and validating the code are that the final product may not meet the user’s requirements or their needs.

The major components of administering testing that must be considered and implemented in order to ensure software quality are to use the appropriate naming conventions, keeping tests small, keeping tests organized within the project directory, keeping tests simple, and creating test cases before development. Each of these are important best practices that I have utilized throughout this course. Utilizing a standardized naming convention and keeping tests organized within the project directory when creating our tests prevents confusion throughout the development process. Keeping tests small and simple also reduces the amount of confusion throughout the development process and makes the overall testing process much more manageable. By creating our test cases before we develop our code, we are reducing the amount of time needed to deliver the final product because we eliminate the need to test the software at the end of the development cycle and ensure that the product will function correctly.

Tools and technology that are available for implementing testing strategies allow the testing process to be more productive. These tools allow us to plan, control, specify, build, execute tests, and analyze test. Testing tools allow testers to track their progress and automate the development process. An example of one of these tools that makes the testing process easier would be Junit, which was used to test the product in this project. Integrating Junit into Eclipse makes the testing process very easy. All the tester has to do is right click a class, create a Junit test, name their test, and create their test cases. This makes the testing process very streamlined and less work intensive for the tester.

The mindset that I adopted while working on this project was carefully think about the different ways the user may use the program and not to presume that the code will behave in the way that I intend it to. I employed caution in not assuming that the product will behave as I expected it to, because in testing it’s better to be paranoid that product might break than be assured that it won’t. It is important to appreciate the complexity of the interrelationships of the code being tested because it in ensures that final product works as intended and meets the client’s requirements.

I tried to limit my bias by being overly cautious in my testing approach. I know that it may be almost impossible for me to cover every possible test case when testing my own code, which is why it is important to have a second opinion from another tester. I believe that bias would be a huge concern when testing our own code, because it is in our human nature to see a product as being complete after we have finished working on it, even though that may not always be the case. When developing a product, we are developing it from our perspective with our own understanding of how the user will use the final product, this understanding and perspective can vary widely between multiple testers and developers. It is a concern if I were responsible for testing my own code because I may not be able to find all of the errors in my own code due to perspective while developing the code and not be able to know if the product with absolute certainty that the final product will function as intended. If I were developing software for a hospital like a life support system this could potentially cost people their lives.

The importance of being disciplined in my commitment to delivering quality software as a software engineer is paramount to my success as a professional software engineer. Making it a habit to implement the best practices throught the testing process ensures that I will always deliver quality products efficiently. It is important to not cut corners when it comes to testing code because doing so could result in major catastrophes and loss of life. Cutting corners will only hurt myself as tester because it will only result in me developing bad habits when creating products for myself or clients. I plan on avoiding technical debt as a practitioner in this field by being humble and disciplined in accomplishing my tasks as a software engineer. I will not assume that my code is without flaws and I will integrate the best testing practices into my testing strategies. As I practice what I have learned throughout this course and gain experience over time I will become a developer that can consistently deliver high quality products.
